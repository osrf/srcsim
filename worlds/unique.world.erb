<?xml version="1.0" ?>
<%
  # SRC finals unique world generator

  # Worlds are generated by stitching walkways one after the other and placing
  # models relevant to the tasks along the walkway path.

  # A complete world with all 3 tasks can be generated as follows:

  # erb unique.world.erb > unique.world

  # Reduced worlds containing only one of the 3 tasks can be generated by
  # passing the task number as an argument, for example:

  # erb t=1 unique.world.erb > unique_task1.world

  ###############################################
  #                                             #
  #           COMMAND LINE ARGUMENTS            #
  #                                             #
  ###############################################

  # Read task number from command line
  vars = ARGV.take_while {|arg| arg[/^\w+=/]}
  ARGV.slice!(0, vars.size)
  vars.each do |var|
    k, v = var.split('=', 2)
    TOPLEVEL_BINDING.eval %Q(#{k} = "#{v}")
  end

  task = '0'
  if (defined? t)
    task = t
  end

  ###############################################
  #                                             #
  #             IMPORT OTHER FILES              #
  #                                             #
  ###############################################

  # Helper function to import another erb file
  def fromFile filename
    return ERB.new(File.read(filename), nil, nil, '_sub01').result(binding)
  end

  ###############################################
  #                                             #
  #            TRANSFORMATION MATRIX            #
  #                                             #
  ###############################################

  require 'matrix'

  # Helper function to create a 2D transform matrix
  def TMatrix(_x, _y, _yaw)
    return Matrix.rows([
             [Math::cos(_yaw), -Math::sin(_yaw), _x],
             [Math::sin(_yaw),  Math::cos(_yaw), _y],
             [0, 0, 1]
           ])
  end

  ###############################################
  #                                             #
  #                    SLOTS                    #
  #                                             #
  ###############################################

  # Each walkway has 2 "slots" where objects can be placed.
  # This function picks one of them randomly.
  # Sets: $slots and $slot
  def randomSlot
    $slots = ["tOriginSlot1", "tOriginSlot2"]
    $slot = $slots.delete $slots.sample
  end

  # Pick the other slot. Should be called after randomSlot.
  # Sets: $slot
  def remainingSlot
    # verify that there is only one slot left?
    $slot = $slots[0]
  end

  ###############################################
  #                                             #
  #                    BLING                    #
  #                                             #
  ###############################################

  # Keep track of how many blings have been added
  $bling_count = 0

  # Dictionary of blings
  $blings = {
    # Model name and transform from slot to origin
    "mars_rock_1" => TMatrix(0, 0.4, 0),
    "mars_rock_2" => TMatrix(0, 0.5, 0),
    "mars_rock_3" => TMatrix(0, 1.1, 0),
    "mars_crate" => TMatrix(0, 0.4, 0),
    "mars_crate_long" => TMatrix(0, 0.8, Math::PI/4),
  }

  # Print a random bling
  # Uses: $blings, $current_frame, $current_walkway, $slot
  # Sets: $bling_count
  def nextBling
    bling = $blings.keys.sample
    bling_frame = $current_frame *
                  $current_walkway[$slot] *
                  $blings[bling]
    $bling_count += 1

    "<include>\n"\
    "      <name>" + bling + "_" + $bling_count.to_s() + "</name>\n"\
    "      <pose>\n"\
    "      " + bling_frame[0, 2].to_s() + "\n"\
    "      " + bling_frame[1, 2].to_s() + "\n"\
    "      " + 0.to_s() + "\n"\
    "      " + 0.to_s() + "\n"\
    "      " + 0.to_s() + "\n"\
    "      " + Math::atan2(bling_frame[1, 0], bling_frame[0, 0]).to_s() + "\n"\
    "      </pose>\n"\
    "      <uri>model://" + bling + "</uri>\n"\
    "    </include>\n"
  end

  ###############################################
  #                                             #
  #                  WALKWAYS                   #
  #                                             #
  ###############################################

  # Geometry
  walkway_length = 1.524
  finish_walkway_length = 3.048
  walkway_height = 0.152151
  $walkway_pos_z = -0.052151

  # Keep track of how many walkways have been added
  $walkway_count = 0

  # Dictionary of walkways
  $walkways = {
    "straight" => {
      # Turn angle
      "angle" => 0,
      # Transformation from entrance to origin
      "tEntranceOrigin" => TMatrix(0, 0, 0),
      # Transformation from origin to exit
      "tOriginExit" => TMatrix(0, walkway_length, 0),
      # Transformation from origin to the 1st slot to place objects
      "tOriginSlot1" => TMatrix(walkway_length * 0.5,
                                walkway_length * 0.5, -Math::PI/2),
      # Transformation from origin to the 2nd slot to place objects
      "tOriginSlot2" => TMatrix(-walkway_length * 0.5,
                                 walkway_length * 0.5, Math::PI/2),
      # SDF model
      "model" => "walkway_metal_straight"
    },
    "-90" => {
      "angle" => -Math::PI/2,
      "tEntranceOrigin" => TMatrix(0, 0, 0),
      "tOriginExit" => TMatrix(walkway_length * 0.5,
                               walkway_length * 0.5, -Math::PI/2),
      "tOriginSlot1" => TMatrix(-walkway_length * 0.5,
                                 walkway_length * 0.5, Math::PI/2),
      "tOriginSlot2" => TMatrix(0, walkway_length, 0),
      "model" => "walkway_metal_90"
    },
    "+90" => {
      "angle" => Math::PI/2,
      "tEntranceOrigin" => TMatrix(-walkway_length * 0.5,
                                    walkway_length * 0.5, -Math::PI/2),
      "tOriginExit" => TMatrix(0, 0, Math::PI),
      "tOriginSlot1" => TMatrix(-walkway_length * 0.5,
                                 walkway_length * 0.5, Math::PI/2),
      "tOriginSlot2" => TMatrix(0, walkway_length, 0),
      "model" => "walkway_metal_90"
    },
    "-45" => {
      "angle" => -Math::PI/4,
      "tEntranceOrigin" => TMatrix(0, 0, 0),
      "tOriginExit" => TMatrix(walkway_length * 0.353983,
                               walkway_length * 0.8535, -Math::PI/4),
      "tOriginSlot1" => TMatrix(-walkway_length * 0.5,
                                 walkway_length * 0.5, Math::PI/2),
      "tOriginSlot2" => TMatrix(-walkway_length * 0.40,
                                 walkway_length * 0.89, Math::PI/4),
      "model" => "walkway_metal_45"
    },
    "+45" => {
      "angle" => Math::PI/4,
      "tEntranceOrigin" => TMatrix(-walkway_length * 0.353983,
                                    walkway_length * 0.8535, -Math::PI*3/4),
      "tOriginExit" => TMatrix(0, 0, Math::PI),
      "tOriginSlot1" => TMatrix(-walkway_length * 0.5,
                                 walkway_length * 0.5, Math::PI/2),
      "tOriginSlot2" => TMatrix(-walkway_length * 0.40,
                                 walkway_length * 0.89, Math::PI/4),
      "model" => "walkway_metal_45"
    },
  }

  # Dictionary of finish box walkways
  $finish_walkways = {
    "straight" => {
      "angle" => 0,
      "tEntranceOrigin" => TMatrix(0, finish_walkway_length * 0.5, -Math::PI/2),
      "tOriginExit" => TMatrix(-finish_walkway_length * 0.5, 0, Math::PI/2),
      "tOriginSlot1" => TMatrix(0, finish_walkway_length * 0.5, 0),
      "tOriginSlot2" => TMatrix(0, -finish_walkway_length * 0.5, Math::PI),
      "model" => "walkway_finish_opposite"
    },
    "-90" => {
      "angle" => -Math::PI/2,
      "tEntranceOrigin" => TMatrix(0, finish_walkway_length * 0.5, -Math::PI/2),
      "tOriginExit" => TMatrix(0, finish_walkway_length * 0.5, 0),
      "tOriginSlot1" => TMatrix(-finish_walkway_length * 0.5, 0, Math::PI/2),
      "tOriginSlot2" => TMatrix(0, -finish_walkway_length * 0.5, Math::PI),
      "model" => "walkway_finish_adjacent"
    },
    "+90" => {
      "angle" => Math::PI/2,
      "tEntranceOrigin" => TMatrix(0, finish_walkway_length * 0.5, Math::PI),
      "tOriginExit" => TMatrix(finish_walkway_length * 0.5, 0, -Math::PI/2),
      "tOriginSlot1" => TMatrix(0, -finish_walkway_length * 0.5, Math::PI),
      "tOriginSlot2" => TMatrix(-finish_walkway_length * 0.5, 0, Math::PI/2),
      "model" => "walkway_finish_adjacent"
    },
  }

  # Pick a walkway randomly
  # Sets: $current_walkway, $current_frame, $total_angle, $walkway_count
  # Parameters:
  # _list: either $walkways or $finish_walkways
  # _no90: do not pick a walkway with a +-90 degree turn. This is used before
  # and after large objects.
  def nextWalkway(_list, _no90)

    # angle of previous walkway
    prev_angle = $current_walkway["angle"]

    # Current walkway end in world frame
    $current_frame = $current_frame * $current_walkway["tOriginExit"]

    new_total = 0

    # Choose next tile so that:
    # - the general direction doesn't go backwards
    # - it doesn't make steep curves (for example, +90 +45)
    # - it's not a 90 degrees turn if _no90 is true.
    loop do

      # Choose a random walkway from the given list
      $current_walkway = _list[_list.keys.sample]

      # Angle of the chosen walkway
      new_angle = $current_walkway["angle"]

      # Total angle from the beginning of the walkway
      new_total = $total_angle + $current_walkway["angle"]

      break if new_total <= Math::PI/2 &&
               new_total >= -Math::PI/2 &&
               !(new_angle < 0 && prev_angle < 0) &&
               !(new_angle > 0 && prev_angle > 0) &&
               !(_no90 && (new_angle.abs() == Math::PI/2))

    end
    $total_angle = new_total

    # Take tile transform into account
    $current_frame = $current_frame * $current_walkway["tEntranceOrigin"]

    $walkway_count += 1

    printWalkway()
  end

  # Print a walkway based on global variables
  # Uses: $walkway_count, $current_frame, $current_walkway, $walkway_pos_z
  def printWalkway()
    "<include>\n"\
    "      <name>walkway_" + $walkway_count.to_s() + "</name>\n"\
    "      <pose>\n"\
    "      " + $current_frame[0, 2].to_s() + "\n"\
    "      " + $current_frame[1, 2].to_s() + "\n"\
    "      " + $walkway_pos_z.to_s() + "\n"\
    "      " + 0.to_s() + "\n"\
    "      " + 0.to_s() + "\n"\
    "      " + Math::atan2($current_frame[1, 0], $current_frame[0, 0]).to_s() + "\n"\
    "      </pose>\n"\
    "      <uri>model://" + $current_walkway["model"] + "</uri>\n"\
    "    </include>\n"
  end

  # Data for box region detection
  box_height = 5.0
  robot_z_pos = 1.1

  # Starting point
  $current_frame = TMatrix(0.09, 0, Math::PI)
%>
<sdf version="1.6">
  <world name="SRC_finals">

    <physics type="ode">
      <real_time_update_rate>1000.0</real_time_update_rate>
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <ode>
        <solver>
          <type>quick</type>
          <iters>150</iters>
          <precon_iters>0</precon_iters>
          <sor>1.400000</sor>
          <use_dynamic_moi_rescaling>1</use_dynamic_moi_rescaling>
        </solver>
        <constraints>
          <cfm>0.000000</cfm>
          <erp>0.800000</erp>
          <contact_max_correcting_vel>2000.000000</contact_max_correcting_vel>
          <contact_surface_layer>0.01000</contact_surface_layer>
        </constraints>
      </ode>
    </physics>

    <!-- GUI -->
    <gui fullscreen='0'>
      <camera name='user_camera'>
        <pose>-4.1 -0.2 3.3 0 0.37 0</pose>
      </camera>
    </gui>

    <!-- Scene -->
    <scene>
      <background>0.968627451 0.690196078 0.384313725 1.0</background>
      <grid>0</grid>
      <origin_visual>0</origin_visual>
    </scene>

    <!-- A global light source -->
    <light type="directional" name="sun">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 1000 <%= rand(-1.0...1.0) %> <%= rand(-1.6...-0.8)%> 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

    <!-- Background -->
    <include>
      <uri>model://heightmap_mars</uri>
    </include>

    <!-- START WALKWAY -->

    <!-- Walkway -->
    <%=
      # Start with a straight walkway
      $current_walkway = $finish_walkways["straight"]
      $total_angle = $current_walkway["angle"]
      $walkway_count += 1
      printWalkway()
    %>

    <!-- Bling -->
    <%=
      randomSlot()
      nextBling()
    %>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <%
      if (task == '0' || task == '1')
    %>

    <!-- TASK 1 -->

    <!-- Task 1 start - Box plugin -->
    <%
      t1start_frame = $current_frame * $current_walkway["tOriginExit"] *
                      TMatrix(0, 0.5, 0)
    %>

    <plugin name="boxT1Start" filename="libBoxContainsPlugin.so">
      <entity>valkyrie</entity>
      <namespace>task1/start</namespace>
      <pose>
        <%= t1start_frame[0, 2] %>
        <%= t1start_frame[1, 2] %>
        <%= box_height * 0.5 %>
        0
        0
        <%= Math::atan2(t1start_frame[1, 0], t1start_frame[0, 0]) %>
      </pose>
      <size><%= walkway_length %> 1 <%= box_height %></size>
    </plugin>

    <!-- Walkway -->
    <%=
      # Can't have 90 degrees near the final box
      nextWalkway($walkways, true)
    %>

    <!-- Satellite -->
    <%
      randomSlot()
      tSatSlotOrigin = TMatrix(0, 2, 0);
      $satellite_frame = $current_frame *
                         $current_walkway[$slot] *
                         tSatSlotOrigin
    %>

    <%= fromFile("satellite.erb") %>

    <!-- Checkpoint 1 - Box plugin -->
    <%
      t1cp1_frame = $satellite_frame * TMatrix(0, -2.4, Math::PI * 0.5)
      t1cp2_frame = t1cp1_frame
    %>

    <plugin name="boxT1CP1" filename="libBoxContainsPlugin.so">
      <entity>valkyrie</entity>
      <namespace>task1/checkpoint1</namespace>
      <pose>
        <%= t1cp1_frame[0, 2] %>
        <%= t1cp1_frame[1, 2] %>
        <%= box_height * 0.5 %>
        0
        0
        <%= Math::atan2(t1cp1_frame[1, 0], t1cp1_frame[0, 0]) %>
      </pose>
      <size>1 1 <%= box_height %></size>
    </plugin>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <!-- Walkway -->
    <%=
      nextWalkway($walkways, true)
    %>

    <!-- Bling -->
    <%=
      randomSlot()
      nextBling()
    %>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <!-- Final box 1 -->
    <%=
      nextWalkway($finish_walkways, false)
    %>

    <!-- Checkpoint 3 - Box plugin -->
    <plugin name="boxT1CP3" filename="libBoxContainsPlugin.so">
      <entity>valkyrie</entity>
      <namespace>task1/checkpoint3</namespace>
      <pose>
        <%= $current_frame[0, 2] %>
        <%= $current_frame[1, 2] %>
        <%= box_height * 0.5 %>
        0
        0
        <%= Math::atan2($current_frame[1, 0], $current_frame[0, 0]) %>
      </pose>
      <size><%= finish_walkway_length %> <%= finish_walkway_length %> <%= box_height %></size>
    </plugin>

    <!-- Bling -->
    <%=
      randomSlot()
      nextBling()
    %>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <%
      t1cp3_frame = $current_frame *
                    $current_walkway["tOriginExit"] *
                    TMatrix(0, -finish_walkway_length * 0.5, Math::PI * 0.5)
    %>

    <!-- /TASK 1 -->
    <%
      end
    %>

    <%
      if (task == '0' || task == '2')
    %>

    <!-- TASK 2 -->

    <!-- Task 2 start - Box plugin -->
    <%
      t2start_frame = $current_frame * $current_walkway["tOriginExit"] *
                      TMatrix(0, 0.5, 0)
    %>

    <plugin name="boxT2Start" filename="libBoxContainsPlugin.so">
      <entity>valkyrie</entity>
      <namespace>task2/start</namespace>
      <pose>
        <%= t2start_frame[0, 2] %>
        <%= t2start_frame[1, 2] %>
        <%= box_height * 0.5 %>
        0
        0
        <%= Math::atan2(t2start_frame[1, 0], t2start_frame[0, 0]) %>
      </pose>
      <size><%= walkway_length %> 1 <%= box_height %></size>
    </plugin>

    <!-- Walkway -->
    <%=
      nextWalkway($walkways, true)
    %>

    <!-- Walkway -->
    <%=
      # Can't have 90 degrees near the rover
      nextWalkway($walkways, true)
    %>

    <!-- Rover -->
    <%
      randomSlot()

      tRoverSlotOrigin = TMatrix(0, 4.5, Math::PI);
      rover_frame = $current_frame *
                    $current_walkway[$slot] *
                    tRoverSlotOrigin
    %>

    <include>
      <pose>
        <%= rover_frame[0, 2] %>
        <%= rover_frame[1, 2] %>
        0
        0
        0
        <%= Math::atan2(rover_frame[1, 0], rover_frame[0, 0]) %>
      </pose>
      <uri>model://mars_explorer</uri>
    </include>

    <!-- Solar panel -->
    <%
      tPanelSlotOrigin = TMatrix(0, -0.2, rand(-Math::PI...Math::PI));
      $solar_panel_frame = $current_frame *
                           $current_walkway[$slot] *
                           tPanelSlotOrigin
      $solar_panel_pos_z = 0.46
    %>

    <%= fromFile("solar_panel.erb") %>

    <!-- Bling -->
    <%=
      # No room for bling if it's a 45 turn
      if $current_walkway['angle'].abs() != Math::PI/4
        remainingSlot()
        nextBling()
      end
    %>

    <!-- Walkway -->
    <%=
      # Can't have 90 degrees near the rover
      nextWalkway($walkways, true)
    %>

    <!-- Walkway -->
    <%=
      # Can't have 90 degrees between the rover and the array
      nextWalkway($walkways, true)
    %>

    <!-- Bling -->
    <%=
      randomSlot()
      nextBling()
    %>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <!-- Walkway -->
    <%=
      # Can't have 90 degrees near the array
      nextWalkway($walkways, true)
    %>

    <!-- Solar Array -->
    <%
      randomSlot()

      tArraySlotOrigin = TMatrix(0, 0.55, 0);
      array_frame = $current_frame *
                    $current_walkway[$slot] *
                    tArraySlotOrigin

      t2cp2_panel_skip_frame = array_frame *
          TMatrix(rand(-0.4...-0.05), rand(-0.2...0.065), rand(-Math::PI...Math::PI));
      t2cp2_panel_skip_z_pos = 0.7

      t2cp2_frame = array_frame * TMatrix(0, -1.2, Math::PI * 0.5);
      t2cp3_frame = t2cp2_frame
      t2cp5_frame = t2cp2_frame
    %>

    <include>
      <pose>
        <%= array_frame[0, 2] %>
        <%= array_frame[1, 2] %>
        0
        0
        0
        <%= Math::atan2(array_frame[1, 0], array_frame[0, 0]) %>
      </pose>
      <uri>model://solar_array</uri>
    </include>

    <!-- Cable -->
    <%
      tCableSlotOrigin = TMatrix(0.4, 1.15, -Math::PI / 2);
      $cable_frame = $current_frame *
                     $current_walkway[$slot] *
                     tCableSlotOrigin
    %>

    <%= fromFile("cable.erb") %>

    <!-- Checkpoint 2 - Box plugin -->
    <%
      panel_goal_frame = array_frame
    %>

    <plugin name="boxT2CP2" filename="libBoxContainsPlugin.so">
      <entity>solar_panel</entity>
      <namespace>task2/checkpoint2</namespace>
      <pose>
        <%= panel_goal_frame[0, 2] %>
        <%= panel_goal_frame[1, 2] %>
        0.9
        0
        0
        <%= Math::atan2(panel_goal_frame[1, 0], panel_goal_frame[0, 0]) %>
      </pose>
      <size>1.47 0.95 0.45</size>
    </plugin>

    <!-- Bling -->
    <%=
      # No room for bling if it's a 45 turn
      if $current_walkway['angle'].abs() != Math::PI/4
        remainingSlot()
        nextBling()
      end
    %>

    <!-- Walkway -->
    <%=
      # Can't have 90 degrees near the array or the final box
      nextWalkway($walkways, true)
    %>

    <!-- Bling -->
    <%=
      randomSlot()
      nextBling()
    %>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <!-- Final Box 2 -->
    <%=
      nextWalkway($finish_walkways, false)
    %>

    <!-- Checkpoint 6 - Box plugin -->
    <plugin name="boxT2CP6" filename="libBoxContainsPlugin.so">
      <entity>valkyrie</entity>
      <namespace>task2/checkpoint6</namespace>
      <pose>
        <%= $current_frame[0, 2] %>
        <%= $current_frame[1, 2] %>
        <%= box_height * 0.5 %>
        0
        0
        <%= Math::atan2($current_frame[1, 0], $current_frame[0, 0]) %>
      </pose>
      <size><%= finish_walkway_length %> <%= finish_walkway_length %> <%= box_height %></size>
    </plugin>

    <!-- Bling -->
    <%=
      randomSlot()
      nextBling()
    %>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <%
      t2cp6_frame = $current_frame *
                    $current_walkway["tOriginExit"] *
                    TMatrix(0, -finish_walkway_length * 0.5, Math::PI * 0.5)
    %>

    <!-- /TASK 2 -->
    <%
      end
    %>

    <%
      if (task == '0' || task == '3')
    %>

    <!-- TASK 3 -->

    <!-- Task 3 start - Box plugin -->
    <%
      t3start_frame = $current_frame * $current_walkway["tOriginExit"] *
                      TMatrix(0, 0.5, 0)
    %>

    <plugin name="boxT3Start" filename="libBoxContainsPlugin.so">
      <entity>valkyrie</entity>
      <namespace>task3/start</namespace>
      <pose>
        <%= t3start_frame[0, 2] %>
        <%= t3start_frame[1, 2] %>
        <%= box_height * 0.5 %>
        0
        0
        <%= Math::atan2(t3start_frame[1, 0], t3start_frame[0, 0]) %>
      </pose>
      <size><%= walkway_length %> 1 <%= box_height %></size>
    </plugin>

    <!-- Walkway -->
    <%=
      t3cp1_frame = t2cp6_frame
      t3cp2_frame = t2cp6_frame
      t3cp3_frame = t2cp6_frame
      t3cp5_frame = t2cp6_frame
      t3cp7_frame = t2cp6_frame
      t3cp8_frame = t2cp6_frame

      # Can't have 90 degrees near the final box
      nextWalkway($walkways, true)
    %>

    <!-- Walkway -->
    <%=
      nextWalkway($walkways, false)
    %>

    <!-- Bling -->
    <%=
      randomSlot()
      nextBling()
    %>

    <!-- Bling -->
    <%=
      remainingSlot()
      nextBling()
    %>

    <!-- Habitat -->
    <%
      # TODO: Habitat goes here
    %>

    <!-- TODO: Put the table inside the habitat -->

    <!-- Table -->
    <%
      $current_frame = $current_frame *
                       $current_walkway["tOriginExit"]

      $table_frame = $current_frame * TMatrix(0, 0.5, 0)
    %>
    <include>
      <pose>
        <%= $table_frame[0, 2] %>
        <%= $table_frame[1, 2] %>
        0
        0
        0
        <%= Math::atan2($table_frame[1, 0], $table_frame[0, 0]) %>
      </pose>
      <uri>model://space_table</uri>
    </include>

    <!-- Air leak detector -->
    <%
      $air_leak_detector_frame = $table_frame
      $table_top_z = 0.7
    %>

    <%= fromFile("air_leak_detector.erb") %>

    <!-- Leak patch tool -->
    <%
      $leak_patch_tool_frame = $table_frame * TMatrix(0.3, 0, 0)
    %>

    <include>
      <pose>
        <%= $leak_patch_tool_frame[0, 2] %>
        <%= $leak_patch_tool_frame[1, 2] %>
        <%= $table_top_z + 0.1 %>
        0
        0
        <%= Math::atan2($leak_patch_tool_frame[1, 0], $leak_patch_tool_frame[0, 0]) %>
      </pose>
      <uri>model://leak_patch_tool</uri>
    </include>

    <!-- Leak -->
    <%= fromFile("leak.erb") %>

    <!-- TODO: Put the box inside the habitat -->

    <!-- Checkpoint 8 - Box plugin -->

    <plugin name="boxT3CP8" filename="libBoxContainsPlugin.so">
      <entity>valkyrie</entity>
      <namespace>task3/checkpoint8</namespace>
      <pose>
        <%= $current_frame[0, 2] %>
        <%= $current_frame[1, 2] %>
        <%= box_height * 0.5 %>
        0
        0
        <%= Math::atan2($current_frame[1, 0], $current_frame[0, 0]) %>
      </pose>
      <size><%= finish_walkway_length %> <%= finish_walkway_length %> <%= box_height %></size>
    </plugin>

    <!-- /TASK 3 -->
    <%
      end
    %>

    <!-- Finals plugin -->
    <plugin name="finals" filename="libFinalsPlugin.so">

      <%
        if (task == '0' || task == '1')
      %>
        <task1>
          <timeout>1800</timeout>

          <checkpoint1>
            <skip_robot_pose>
              <%= t1cp1_frame[0, 2] %>
              <%= t1cp1_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t1cp1_frame[1, 0], t1cp1_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint1>

          <checkpoint2>
            <skip_robot_pose>
              <%= t1cp2_frame[0, 2] %>
              <%= t1cp2_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t1cp2_frame[1, 0], t1cp2_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint2>

          <checkpoint3>
            <skip_robot_pose>
              <%= t1cp3_frame[0, 2] %>
              <%= t1cp3_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t1cp3_frame[1, 0], t1cp3_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint3>
        </task1>
      <%
        end
      %>

      <%
        if (task == '0' || task == '2')
      %>
        <task2>
          <timeout>3600</timeout>

          <checkpoint1>
          </checkpoint1>

          <checkpoint2>
            <skip_robot_pose>
              <%= t2cp2_frame[0, 2] %>
              <%= t2cp2_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t2cp2_frame[1, 0], t2cp2_frame[0, 0]) %>
            </skip_robot_pose>
            <panel_pose>
              <%= t2cp2_panel_skip_frame[0, 2] %>
              <%= t2cp2_panel_skip_frame[1, 2] %>
              <%= t2cp2_panel_skip_z_pos %>
              0
              0
              <%= Math::atan2(t2cp2_panel_skip_frame[1, 0], t2cp2_panel_skip_frame[0, 0]) %>
            </panel_pose>
          </checkpoint2>

          <checkpoint3>
            <skip_robot_pose>
              <%= t2cp3_frame[0, 2] %>
              <%= t2cp3_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t2cp3_frame[1, 0], t2cp3_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint3>

          <checkpoint4>
          </checkpoint4>

          <checkpoint5>
            <skip_robot_pose>
              <%= t2cp5_frame[0, 2] %>
              <%= t2cp5_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t2cp5_frame[1, 0], t2cp5_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint5>

          <checkpoint6>
            <skip_robot_pose>
              <%= t2cp6_frame[0, 2] %>
              <%= t2cp6_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t2cp6_frame[1, 0], t2cp6_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint6>

        </task2>

      <%
        end
      %>

      <%
        if (task == '0' || task == '3')
      %>
        <task3>
          <timeout>7200</timeout>

          <checkpoint1>
            <skip_robot_pose>
              <%= t3cp1_frame[0, 2] %>
              <%= t3cp1_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t3cp1_frame[1, 0], t3cp1_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint1>

          <checkpoint2>
            <skip_robot_pose>
              <%= t3cp2_frame[0, 2] %>
              <%= t3cp2_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t3cp2_frame[1, 0], t3cp2_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint2>

          <checkpoint3>
            <skip_robot_pose>
              <%= t3cp3_frame[0, 2] %>
              <%= t3cp3_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t3cp3_frame[1, 0], t3cp3_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint3>

          <checkpoint4>
          </checkpoint4>

          <checkpoint5>
            <skip_robot_pose>
              <%= t3cp5_frame[0, 2] %>
              <%= t3cp5_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t3cp5_frame[1, 0], t3cp5_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint5>

          <checkpoint6>
          </checkpoint6>

          <checkpoint7>
            <skip_robot_pose>
              <%= t3cp7_frame[0, 2] %>
              <%= t3cp7_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t3cp7_frame[1, 0], t3cp7_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint7>

          <checkpoint8>
            <skip_robot_pose>
              <%= t3cp8_frame[0, 2] %>
              <%= t3cp8_frame[1, 2] %>
              <%= robot_z_pos %>
              0
              0
              <%= Math::atan2(t3cp8_frame[1, 0], t3cp8_frame[0, 0]) %>
            </skip_robot_pose>
          </checkpoint8>

        </task3>
      <%
        end
      %>

    </plugin>

  </world>
</sdf>
